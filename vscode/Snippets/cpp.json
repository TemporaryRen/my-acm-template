{
	"acm contest template":{
		"prefix": ["acmz"],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"#define forn(i, l, r) for(int i=l;i<r;i++)",
            "#define for0(i, r, l) for(int i=r;i>l;i--)",
			"#define all(a) a.begin(),a.end()",
			"#define forn(i, l, r) for(int i=l;i<r;i++)\n",
			"void solve(){",
			"}",
			"\n",
			"int main() {",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"\tcout.tie(nullptr);",
			"\tint tc = 1;",
			"\tcin >> tc;",
			"\tfor (int t = 1; t <= tc; t++) {",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
	],
		"description": "acm contest template"
	},
	"string prefix array function":{
		"prefix": ["pi_fun"],
		"body": [
			"vector<int> pi_fun(string s) {",
			"\tint n = s.size();",
			"\tvector pi(n,0);",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tint j = pi[i - 1];",
			"\t\twhile (j > 0 && s[i] != s[j])j = pi[j - 1];",
			"\t\tif (s[i] == s[j]) ++j;",
			"\t\tpi[i] = j;",
			"\t}",
			"\treturn pi;",
			"}"

		],
		"description": "string prefix array function"
	},
	"kmp search":{
		"prefix": ["kmp_fun"],
		"body": [
			"vector<int> pi_fun(string s) {",
			"\tint n = s.size();",
			"\tvector pi(n,0);",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tint j = pi[i - 1];",
			"\t\twhile (j > 0 && s[i] != s[j])j = pi[j - 1];",
			"\t\tif (s[i] == s[j]) ++j;",
			"\t\tpi[i] = j;",
			"\t}",
			"\treturn pi;",
			"}",
			"\n",
			"void kmp(string s,string t){",
			"\tauto pi = pi_fun(t);",
			"\tint n = s.size();",
			"\tint m = t.size();",
			"\tint j = 0;",
			"\tfor(int i=0;i<n;i++){",
			"\t\tchar c = s[i];",
			"\t\twhile(j>0 && c!=t[j]) j = pi[j-1];",
			"\t\tj += (c==t[j]);",
			"\t\tif(j==m){",
			"\t\t\t//match success and do something",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "kmp function"
	},
	"Z function":{
		"prefix": ["Z_fun"],
		"body":[
			"vector<int> Z_fun(string s){",
			"\tint n = s.size();",
			"\tvector Z(n,0);",
			"\tfor(int j=1,l=0,r=0;j<n;j++){",
			"\t\tZ[j] = max(0,min(r-j+1,Z[j-l]));",
			"\t\twhile(j+Z[j]<n&&s[j+Z[j]]) ++Z[j];",
			"\t\tif(j+Z[j]-1 > r){",
			"\t\t\tr = j+Z[j]-1;",
			"\t\t\tl = j;",
			"\t\t}",
			"\t}",
			"\treturn Z;",
			"}"
		],
		"description": "Z function"

	},
	"manacher":{
		"prefix": ["manacher"],
		"body":[
			"vector<int> manacher(const string& s){",
			"\tint n = s.size();",
			"\tvector ret(n,0);",
			"\tint l = 0, r = 0;",
			"\tfor(int i=1;i<n;i++){",
			"\t\tret[i] = max(0,min(ret[max(0,2*l-i)],r-i));",
			"\t\twhile(i+ret[i]+1<n&&i-ret[i]-1>=0&&s[i+ret[i]+1]==s[i-ret[i]-1]) ++ret[i];",
			"\t\tif(i+ret[i]>r){",
			"\t\t\tl = i;",
			"\t\t\tr = i+ret[i];",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}"
		],
		"description": "manacher function"
	},
	"sparse table": {
		"prefix": ["sparse_table"],
		"body": [
			"template < typename T, typename Comp = std::less< T > >",
			"class sparse_table {",
			"private:",
			"\tstd::vector< T > data;",
			"\tstd::vector < std::vector < size_t > > table;",
			"\tvoid build_table();",
			"\tinline static unsigned mlog(size_t _n);",
			"public:",
			"\tconst size_t size() const { return data.size(); }",
			"\tsparse_table(const std::vector< T >& _data) : data(_data) {",
			"\t\tbuild_table();",
			"\t}",
			"\ttemplate < typename ItT >",
			"\tsparse_table(ItT begin, ItT end) {",
			"\t\twhile (begin != end) {",
			"\t\t\tdata.push_back(*begin);",
			"\t\t\t++begin;",
			"\t\t}",
			"\t\tbuild_table();",
			"\t}",
			"\tconst T& get_min(const size_t L, const size_t R) const;",
			"};",
			"",
			"template < typename T, typename Comp >",
			"void sparse_table< T, Comp >::build_table() {",
			"\tif (!data.size()) {",
			"\t\tthrow std::invalid_argument(\"Empty set is passed as a parameter.\");",
			"\t}",
			"\ttable.resize(1);",
			"\ttable[0].resize(data.size());",
			"\tfor (size_t i = 0; i < data.size(); ++i) {",
			"\t\ttable[0][i] = i;",
			"\t}",
			"\tunsigned pow = 1;",
			"\tconst unsigned max_pow = mlog(data.size());",
			"\ttable.resize(max_pow + 1);",
			"\tconst Comp cmp;",
			"\tfor (; pow <= max_pow; ++pow) {",
			"\t\tconst size_t cur_step_len = static_cast< size_t >(1) << pow,",
			"\t\t\tprev_step_len = static_cast< size_t >(1) << (pow - 1);",
			"\t\ttable[pow].resize(data.size() - cur_step_len + 1);",
			"\t\tfor (int i = 0; i <= data.size() - cur_step_len; ++i) {",
			"\t\t\ttable[pow][i] = cmp(data[table[pow - 1][i]], data[table[pow - 1][i + prev_step_len]]) ?",
			"\t\t\t\ttable[pow - 1][i] : table[pow - 1][i + prev_step_len];",
			"\t\t}",
			"\t}",
			"}",
			"",
			"template < typename T, typename Comp >",
			"inline unsigned sparse_table< T, Comp >::mlog(const size_t _n) {",
			"\tregister size_t n = _n, k = 0;",
			"\twhile ((static_cast< size_t >(1) << k) <= n) {",
			"\t\t++k;",
			"\t}",
			"\treturn k - 1;",
			"}",
			"",
			"template < typename T, typename Comp >",
			"const T& sparse_table< T, Comp >::get_min(const size_t L, const size_t R) const {",
			"\tif (L > data.size() || R == 0 || R > data.size()) {",
			"\t\tthrow std::out_of_range(\"Wrong index is used.\");",
			"\t}",
			"\tif (L >= R) {",
			"\t\tthrow std::invalid_argument(\"Wrong arguments in query.\");",
			"\t}",
			"\tconst unsigned pow = mlog(R - L);",
			"\tconst Comp cmp;",
			"\tconst size_t check_len = static_cast< size_t >(1) << pow;",
			"\treturn cmp(data[table[pow][L]], data[table[pow][R - check_len]]) ?",
			"\t\tdata[table[pow][L]] : data[table[pow][R - check_len]];",
			"}"
		],
		"description": "sparse table implementation"
	}
}